---
title: 译 Backends For Frontends
date: 2018/12/13 21:13:51
categories: '译'
---

# [译] Backends For Frontends

> 原文：[Backends For Frontends](https://samnewman.io/patterns/architectural/bff/)
> 作者：Sam Newman

## 介绍
随着web的出现和成功，UI的实际方式已经从笨重的客户端应用转移到web应用，这一趋势也使得基于saas的解决方案的增长成为可能。通过web交付产品的好处是巨大的，可以大大降低发布新版本的成本，因为客户端需要安装的成本完全消除了。

但是这个简单的环境并没有持续太久，因为移动时代也随之而来。现在我们有个问题。我们希望把服务端功能同时开放给桌面web UI和一个或多个移动UI。但是由于最初开发系统时考虑的是web UI，我们在适配这些移动端UI时经常遇到兼容性问题，因为在web UI和后端服务之间建立了紧密的耦合。

## 通用的后端架构
要适应不止一种类型的UI，第一步通常是提供一个单一的服务端API，并随着时间的推移不断添加更多的功能，以支持新的移动交互类型:
<div align=center>![](http://dry-image.test.upcdn.net/bff1.jpg)</div>
如果这些不同的UI对接口的调用十分相似的话，那么这种通用API很容易实现。但是，移动端体验从本质上就与web端有很大的不同。首先，移动端可提供的功能不同。移动端提供的屏幕更小，我们只能显示更少的数据。过多对服务器的请求会耗尽电池寿命和有限的数据计划。其次，我们希望在移动端上提供的交互是完全不同的。想想一个典型的实体零售商。在桌面应用程序上，我可能允许你查看待售商品、在线订购或在商店预订。不过，在移动端上，我可能想让你扫描条形码进行价格比较，或者提供优惠。随着我们构建了越来越多的移动app，我们开始意识到人们使用它们的交互非常不同，因此我们需要提供的功能也会有所不同。
所以在实际上，移动端希望得到不同，更少的接口，并希望展示与桌面端不同（尽量少）的数据。这意味着我们需要提供额外的API来支持移动端应用。
通用API的另一个问题是，它们是用来为多个面向用户的应用程序提供功能的。这意味着在我们交付新功能时单个API可能成为瓶颈，比如许多修改都可能是对同一个模块的更改。
通用API后端往往承担多个职责，因此需要大量工作，这常常导致专门创建一个团队来维护这些代码。这可能使问题更糟,因为现在前端团队必须与一个单独的团队进行对接以进行更改 - 这个团队必须平衡不同客户团队的优先级,同时要与多个下游团队合作，在新的API可用时去使用它们。可以说在这一点上，我们已经在我们的架构中创建了一个智能中间件，这个中间件并不专注于任何特定的业务领域 - 这与许多人设想中的合理的面向服务的架构完全相悖。
<div align=center>![](http://dry-image.test.upcdn.net/bff2.jpg)</div>

## BFF的介绍
我在REA和SoundCloud中使用过的一个解决方案是，每个客戶端有一个对应的后端服务，而不是只有一个通用的API后端，称之为服务于前端的后端(Backend For Frontend)。 从概念上讲，应该将面向用户的应用程序视为两个组件：面向用户的客户端应用程序和对应的服务器端组件（BFF）。

BFF与特定的客户端用户体验紧密耦合，通常由一个团队维护接口，从而使接口更容易定义和适配UI的需求，同时还简化了客户端和服务器两者的发布流程。

    <div align=center>![](http://dry-image.test.upcdn.net/bff3.jpg)</div>

BFF专注于单个客户端，这使得它更集中且更小巧。

## 应该设计多少个BFF？
当设计到在不同平台上提供相同（或类似）的用户体验时，我看到了两种不同的方法。我更喜欢的模型是为每种不同类型的客户端做一个BFF  - 这是我在REA看到的模型：
    <div align=center>![](http://dry-image.test.upcdn.net/bff4.jpg)</div>
我在SoundCloud使用的另一个模型是，每种类型的用户界面使用一个BFF，因此Android和iOS版本的原生应用程序使用相同的BFF：
    <div align=center>![](http://dry-image.test.upcdn.net/bff5.jpg)</div>

我对于第二个模型的关注点是，使用单个BFF的客户端类型越多，就越容易因为处理多个问题而变得臃肿。这里要理解的关键是，即使共享BFF，它也只适用于同一类用户界面,虽然SoundCloud的iOS和Android平台的app使用相同的BFF，但其他平台的应用将使用不同的BFF。如果同一团队维护开发Android和iOS应用程序和BFF层，我也会更轻松地使用这个模型，但如果这些应用程序由不同的团队维护，我倾向于推荐更严格的模型。 因此，团队的组织架构视是选择模型主要驱动因素之一。值得注意的是，和我交流过的SoundCloud工程师建议，如果今天重新做决定，为Android和iOS应用程序提供一个统一BFF是需要重新考虑的。
我非常喜欢Stewart Gleadow的一个指导原则是“一种体验，一个BFF”。 所以如果iOS和Android体验非常相似，那么共同使用一个BFF没问题。 然而，如果他们分歧很大，那么拥有单独的BFF就更有意义了。
Pete Hodgson观察到BFF在团队边界对齐时效果最好，应该由团队结构来驱动拥有多少个BFF。 因此，如果有一个移动团队，那么应该有一个BFF，但如果有单独的iOS和Android团队，那么它们各自应该拥有单独的BFF。 我担心的是团队结构往往比我们的系统架构更流畅更容易改变。 如果你有一个服务于移动端的BFF，那么将团队分成iOS和Android，那么是否必须拆分BFF？ 如果BFF已经分开，那么拆分团队会更容易，因为您可以重新分配已经独立的资源。 BFF和团队结构的相互作用很重要。
为了避免服务器端代码冗余，通常希望BFF数量少一点，但是有其他方法可以来处理这个问题。

## 多个微服务
BFF对于只有少量后端服务的架构来说是一种有用的模式。但是对于使用大量服务的业务架构来说，它们可能是必不可少的，因为大量的业务需求需要聚合多个下游微服务。在这种情况下，对BFF的单个接口调用通常会导致对多个下游微服务调用。例如一个电子商务公司的应用，我们想要展示一个用户的愿望列表，显示它的库存和价格。
这些信息存储在于多个微服务中，`Wishlist`微服务存储列表和ID，`Catalog` 微服务存储它们的名称和价格，`Inventory` 微服务存储库存量，所以我们需要提供一个至少包含3次调用的方法来获取整个列表信息：
    <div align=center>![](http://dry-image.test.upcdn.net/bff6.jpg)</div>
从效率的角度来看，并行执行尽可能多的接口调用会更明智。理想情况下，一旦对`Wishlist`服务的初始调用完成，我们希望同时执行对其他服务的调用，这样可以减少总的调用时间。这就需要我们将希望并行执行的调用与顺序执行的调用混合起来，但这会变得难以管理，尤其是对于更复杂的业务场景。
理解失败的模式是很重要的。在上面的示例中，我们可以坚持所有下游调用都必须返回，以便将有效负载返回给客户端。然而，这明智吗?显然，如果`Wishlist`服务关闭了，我们就无能为力了，但是如果`Inventory`服务关闭了，减少返回给客户端的功能不是更好吗?在第一个实例中，这些关注点必须由BFF本身管理，但是我们还需要确保调用BFF的客户端能够解释部分响应并正确呈现它。
## 重用和BFF
每个UI对应一个BFF的问题是，BFF之间可能会出现大量重复逻辑和代码。例如，它们可能最终使用相同类型的聚合，具有用于与下游服务交互的类似代码等等。有些人对此的反应是希望将它们合并在一起，从而拥有一个通用的聚合API服务。这个模型已经一次又一次地证明，它会导致大量的冗余代码。
我之前已经多次提到过，对于跨服务的重复代码，我并不担心。虽然在单个服务中，我会尽量将重复业务抽象出来，但对于跨服务的重复代码，我不会这么做。我更担心的一点是，提取共享代码模块会导致服务器之间的紧密耦合。
我的同事Pete Hodgson指出，当你没有BFF时，相同的逻辑最终会融入到不同的客户端中。由于实际上这些客户端使用不同的技术栈，因此很难确定这种复制。由于组织倾向于为服务器端提供一个通用的技术栈，因此有多个具有重用代码的bff可能更容易被发现和提取出来。
当需要提取共享代码时，有两个方法。第一个是提取某种共享库，便宜但是复杂。因为共享库会造成耦合，特别是当它用来调用下游服务的的客户端库时。尽管如此，在某些情况下这是合理的，特别是当抽象的代码块完全是服务内部的一个关注点时。
另一个方法是将共同功能抽象成一个新的服务，如果你能将它概念化，并对相关领域进行建模，那么它就能很好的工作。
这种方法的一个变体是将聚合职责进一步推到服务的下游。以上面讨论愿望列表的例子为例。让我们想象一下，我们在Android和iOS上分别呈现一个愿望列表。每个BFF都需要进行相同的3次调用：
<div align=center>![](http://dry-image.test.upcdn.net/bff7.jpg)</div>
我们也可以更改`Wishlist`服务来为我们进行下游调用，从而简化了上层调用者的工作:
<div align=center>![](http://dry-image.test.upcdn.net/bff8.jpg?center)</div>

在两个地方使用相同的代码并不一定会使我以这种方法提取出一个服务,如果创建一个新的服务的成本足够低,我肯定会考虑,或者我可以在多几个地方使用它(比如在桌面web上)。

## 为桌面web和其他服务的BFF
你可以把BFF看作是解决移动设备限制的工具。桌面web体验通常是在功能更强大、连接更好的设备上提供的，在这些设备上，进行多个下游调用的成本是可控的。这允许web应用程序直接对下游服务进行多个服务调用，而不需要经过BFF。
我也看到过在web上使用BFF的。当使用服务器渲染时，在服务器端生成大量web页面，BFF是可以做到这一点的。它还可以简化有些可以放置一个反向代理缓存BFF的前面,让你缓存聚合调用的结果(虽然你必须确保你设置相应的缓存控制以确保聚合内容的到期一样短的新鲜内容聚合需要它)。事实上，我已经看到它被多次使用，而没有将其称为BFF——事实上，通用API后端常常是由这样一个庞然大物发展而来的。
我已经看到至少一个机构将BFF作为第三方调用的服务。比如我长期以来的音乐商店的例子，我可能提供一个BFF，允许第三方提取版税支付信息，提供facebook集成，或者允许流式传输到机顶盒设备。
<div align=center>![](http://dry-image.test.upcdn.net/bff9.jpg)</div>
这种方法特别有效，因为第三方常常无法(或不希望)使用或更改API。如果使用通用API后端，就不得不保留API的旧版本，以满足无法进行更改的第三方开发人员的一小部分需求。使用BFF，这个问题将大大减少。
## 自治
我们经常看到一种情况是，两个团队前后端分离地进行开发。通常我们是试图转移到围绕业务垂直领域的微服务来避免这种情况，但是经常出现难以避免的情况。首先，在一定的规模和复杂性上，需要多个团队参与。其次，实现优秀的移动端体验对技能深度有很高的要求，需要专业的团队。
因此，开发UI的团队面临的情况是，他们调用的API是由另一个团队开发的，而且在开发UI的过程中，API常常在不断发展。BFF可以在这方面提供帮助，特别是当它由开发UI的团队拥有时。他们开发BFF的API的同时开发前端，可以快速地迭代。BFF本身仍然需要调用其他下游服务，但是这可以在不中断前端开发的情况下完成。
<div align=center>![](http://dry-image.test.upcdn.net/bff10.jpg)</div>
使用像这样沿着团队边界对齐的BFF的另一个好处是，创建接口的团队可以更加灵活地考虑功能的位置。例如，他们可以决定将功能推到服务器端，以促进未来的重用并简化本地移动应用程序，或者允许更快地发布新功能(因为您可以绕过app store审查流程)。如果团队同时拥有移动应用程序和BFF，那么他们可以单独做出决定，而不需要任何跨团队协作。

## 常见的周边问题
有些人使用BFF来实现一般的周边问题，比如身份验证/授权或请求日志记录。这件事让我左右为难。一方面，这个功能非常通用，我倾向于使用位于更上游的另一层来实现它，可能使用类似于Nginx或Apache服务器层的东西。另一方面，这样的附加层只能增加延迟。BFF通常用于微服务环境，在微服务环境中，由于要进行大量的网络调用，我们已经对延迟非常敏感。此外，你需要部署的层越多，就会使开发和测试变得越复杂，因此在BFF中作为一个自包含的解决方案来考虑所有这些问题是很有吸引力的:
<div align=center>![](http://dry-image.test.upcdn.net/bff11.jpg)</div>
就像我们前面讨论的，解决这种重复的另一种方法是使用共享库。假设您的BFFs正在使用相同的技术，这应该不会太难，尽管在微服务体系架构中是避免使用共享库的。

## 什么时候使用BFF
对于只提供web UI的应用程序，我认为BFF只有在服务器端需要做大量聚合时才有意义。否则我认为其他UI组件技术也可以很好地实现，而不需要额外的服务器端组件。
在你需要为移动端或第三方应用提供特定功能时，我强烈推荐一开始就为每一个客户端实现一个BFF。如果额外部署一个服务的成本很高时，我会重新考虑，但是BFF带来的好处是显而易见的。如果前端开发与下游服务之间存在明显的分离，我倾向于使用BFF。

## 结论
BFF解决了微服务架构下移动端开发的痛点。它还为通用API后端提供了一个很好的替代方案，许多团队将它们应用于移动开发以外的其他地方。限制他们所支持的消费者数量的简单行为使他们更容易工作和更改，并帮助开发面向客户应用的团队保持更多的自治权。

