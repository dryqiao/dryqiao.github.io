---
title: vue实现2048
date: 2018/04/07 19:20:03
categories: 前端 vue
---
# vue实现2048

清明节，小雨，在家养生，无聊想写点小游戏玩玩，就想到了2048

[试玩地址](https://dryqiao.github.io/vue-2048/)

[项目地址](https://github.com/dryqiao/vue-2048)

使用方法：
```
git clone
npm i
npm run dev
```
## 实现思路
1. 用vue-cli搭建项目，对这个项目可能有点笨重，但是也懒的再搭一个
2. 4X4的方格用一个二维数组存放，绑定好后只关心这个二维数组，其他事交给vue
3. 监听键盘事件
3. 2048的核心部分就是移动合并的算法，因为是一个4X4的矩阵，所以只要实现左移的算法，其他方向的移动只需要将矩阵旋转，移动合并，再旋转回来，渲染dom即可
4. 绑定不同数值的样式
5. 分值计算，以及用localstorage存放最高分

## 关键实现

### DOM

```
<div class="box">
    <div class="row" v-for="row in list">
        <div class="col" :class="'n-'+col" v-for="col in row">{col}}</div>
    </div>
</div>
```
主要的游戏部分的DOM，很简单，用一个二维数组渲染，并动态绑定样式

### 左移

主要由以下几种情况：

- 2 2 2 2 => 4 4 0 0

- 4 2 2 2 => 4 4 2 0

- 0 4 2 2=> 4 4 0 0

- 2 2 4 2 => 4 4 2 0

按单行数据举例，
1. 遍历单行数组，若存在数据，记为cell，寻找cell往左可移到的最远空位置farthest
2. 判断farthest的左边是否存在，不存在则直接移到到farthest
3. 若存在，则判断farthest - 1的值和cell是否相同
4. 相同=> 合并
5. 不相同=>移到farthest位置
5. 移动完后，清空cell
6. 下一轮

因为一轮移动中，一个数只能合并一次，所以每个格子要有merged参数来记录是否已经合并过。

主要代码:
```
    _list.forEach(item => {
        let farthest = this.farthestPosition(list, item)
        let next = list[farthest - 1]
        if (next && next === item.value && !_list[farthest - 1].merged) {
            //合并
            list[farthest - 1] = next * 2
            list[item.x] = undefined
            item = {
                x: farthest - 1,
                merged: true,
                value: next * 2
            }
            this.score += next * 2
        } else {
            if (farthest != item.x) {
                list[farthest] = item.value
                list[item.x] = undefined
                item.x = farthest
            }
        }
    })
```

### 矩阵旋转

因为上移，下移，左移，右移实际上是相同的，写4遍也可以，但是容易出错，所以我直接旋转将矩阵旋转，再进行移动。

以上移为例，只要将矩阵逆时针旋转一次，上移就变成了左移，移动合并成之后，只要再将矩阵逆时针旋转4-1次，矩阵就和单纯上移一样了。

逆时针旋转算法：
```
    rotate(arr, n) {
        n = n % 4
        if (n === 0) return arr
        let tmp = Array.from(Array(this.size)).map(() => Array(this.size).fill(undefined))
        for (let i = 0; i < this.size; i++) {
            for (let j = 0; j < this.size; j++) {
                tmp[this.size - 1 - i][j] = arr[j][i]
            }
        }
        if (n > 1) tmp = this.rotate(tmp, n - 1)
        return tmp
    },
```

到这时候已经完成了80%了，只要再完善一下，加入分值，重新开始等功能就可以了。

写得比较粗糙，有好的意见欢迎提issue。